Here we Go
The why and how of Go for Cogs
15:04 4 Apr 2018

* Go

  Everyone knows that debugging is twice as hard as writing a program in the first place. 
  So if you're as clever as you can be when you write it, how will you ever debug it?
  - Brian Kernighan

* Why Go?

- Go has many characteristics favorable to developing microservices
- Go scales well with team size
- Go helps reduce infrastructure complexity

* Microservice Development

- Performance matters. Cumulative latency is an issue
- Go's std lib provides robust networking capabilities
- Built in concurrency simplifies working with networked systems

* Maintainability

- Static typing aids discoverability (no grepping required)
- The compiler catches an entire category of errors
- The language favors explicitness, which aids readability and maintenainability
- Static typing enables tooling to further aid development
- Refactoring is greatly simplified

  Indeed, the ratio of time spent reading versus writing is well over 10 to 1.
  We are constantly reading old code as part of the effort to write new code. 
  Therefore, making it easy to read makes it easier to write.

  â€• Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship

* Reduced Complexity

- Most requests can be handled synchronously
- We can work with RabbitMQ directly
- Fanning out requests is trivial


* Developer experience
[EJG In progress...]
- Something about GOPATH....
- Go is NOT an Objected Oriented language
- Something about favoring configuration over convention
- provide tool links

* Packages

- foundational visibility mechanism
- a directory of files
- will build a binary if `main.go` exists
- can be imported into other packages, even remotely
- integral to the build system
- crucial aspect of system design

  $ cat ./pkg/somepackage/main.go

  package somepackage

  import 'github.com/taboularasa/gosf/otherpackage'

  func main() {

  }

: foreshadow dataflow
: packages predicate all other visibility aspects in the language
: the public API of a package is defined by exported members, any reference which starts with a capital letter
: all other aspects of the package are private
: all private references can be used freely within a package


* Interfaces
[EG]

Something about Interfaces

* Closures

- functions are first class
- functions can be passed as arguments
- functions close over (keep a reference to) local variables in their lexical scope

.play closure.go

: closure holds reference to local variables that were defined in the same scope as where the function was defined
: many patterns exist that leverage closure
: e.g. functional arguments

* Concurrency
[EG]
: talk about dataflow

Something about Concurrency

* Paradigm

.image paradigm.png

- Go has light/weak support for OO and Functional
- Go works best by applying all paradigms in even proportions
- procedural shell, functional core
: multi paradigm languages typically allow for optional application of some paradigm

: functional:
:   - functions are first class
:   - closures
:   - lack of generics prevent most higher order functions to be implemented effectively
: OO:
:   - instances of structs can have encapsulated state and behavior
:   - code reuse accomplished via composition
:   - lack of inheritance prevents many OO patterns

* Testing
[EG]

Something about Testing

* Resources

.link https://tour.golang.org/welcome/1 A tour of Go
.link https://gobyexample.com/ Go by Example
.link https://dave.cheney.net/ Dave Cheeney
.link https://www.youtube.com/playlist?list=PL64wiCrrxh4Jisi7OcCJIUpguV_f5jGnZ Just for func
.link https://www.usegolang.com/ Something like Hartl's Rails Tutorial
.link http://exercism.io/languages/go/about Exercism

* Stitch Fix resources
[EG]

Something about Stitch Fix resources

